# Redis
## 一、Redis 基础
### 1. Redis都有哪些数据类型？分别在哪些场景下用比较合适？
redis有五种数据类型：String、list、hash、set、sortedSet。  
String：普通的k-v键值对，做简单的存储，value是二进制安全的，可以存储图片等二进制数据；  
list：有序可重复的集合，用来做IM里的好友列表；也用来做下拉分页，提高查询的效率；也可以做个简单的消息队列。  
hash：类似java里map结构，一般可以将结构性数据放入hash中，便于对象的数据操作。  
set：无序不可重复的集合，分布式系统的全局去重功能，同时也提供了交、并、差集操作，比如交集可以分析出两个好友列表的共同好友。  
zset：带score的set，排序的set，排行榜，时间排序，可以放入时用时间作为分数就可以排序了。
### Redis 的高并发
1. 单机瓶颈：单机版的redis 因为物理机的性能，是存在瓶颈的，QPS大概在3万左右，无法支撑10万级别的并发请求。  
2. 实现方式：通过读写分离，搭建redis 的主从架构，master-slave，master 支持写，slave支持读，每台机器3wQPS，3台slave就可以支撑10wQPS了，master 通过数据同步将数据复制给slave，以保证数据的一致性。  
3. 数据复制对主从架构的意义：
## Redis 为什么这么快
1. 基于内存操作，速度快
2. value支持多种数据类型，每种数据类型有自己的本地方法
3. k-v操作，简单的键值对操作，只做存储
4. worker 单线程，redis6 开始支持IO多线程，支持更高的并发

## 3 Redis 缓存问题
### 1. 缓存雪崩  
现象：缓存数据失效，大量请求打入db，导致数据库宕机，大量服务失败，最终导致系统失败。
解决方案：  
1）事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃  
2）事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL被打死  
3）事后：redis持久化，快速恢复缓存数据  
### 2. 缓存穿透  
现象：异常数据，缓存和数据库中都没有，大量请求异常数据，导致数据库宕机。  
解决方案：  
1）服务请求校验  
2）如果数据没查到，直接写到缓存里
### 3. 缓存与数据库双写一致性  
cache aside pattern：读，先读缓存，再读数据库更新缓存；写，先删除缓存，再写数据库；  
为什么写时不更新缓存？  
1）缓存的数据可能不仅仅是一张表、一个系统，可能涉及多个系统的交互，所以更新的话需要查询其他系统，影响性能；  
2）缓存的28原则，20%的缓存，占用80%的使用时间，所以没有必要每次都更新缓存，可能改的数据，10分钟只有一次查询；  
现象：并发发生读、写时，写请求删除缓存，更新数据还未成功，此时读请求过来，发现缓存为空，读请求会去数据库查询数据并更新缓存，此时写请求更新数据完成，数据库和缓存的数据不一致。低并发时，不一致的情况可能很少；发生在高并发的场景下。  
解决方案：数据库和缓存更新与读取操作进行异步串行化。更新数据的时候，将请求hash路由到jvm内存队列中，对应一个线程处理，将更新缓存和读取缓存操作放到内存队列中。  
优化点：连续多个读请求可以优化为一个请求，因为读请求更新缓存只需要一次即可，其他请求可以挂起一会，轮询缓存；如果在规定时间没有返回，直接查询数据库当前数据值返回。  
高并发场景下，注意的问题：  
1）如果有大量更新缓存，读缓存会发生大量的超时，然后走数据库，务必测试更新频率；普通情况下，更新缓存的情况是很少的，都是读高并发。  
2）如果真的写并发很多，那么可以增加机器，减少单个内存队列的压力；必须做好压力测试  
3）多实例部署，必须保证，数据库更新操作和缓存更新操作在同一个服务内，这样才能使用同一个jvm内存队列，否则还是并行的。  
4）热点数据，还是会存在请求的倾斜，导致读写到同一个服务器中，导致某个服务器的负载比较大，但是只要更新数据不是很频繁，不会删除缓存，还是可以的。
### 4. 并发竞争问题  
现象：多个客户端并发写一个key，可能本应该先到的数据后到了，数据版本错了。  
解决方案：分布式锁（确保超时是串行的，每次只能被一个客户端写）+ 时间戳/版本号（如果时间戳靠前、版本号小，数据就不能写入缓存）

## 4 生产环境Redis怎么部署的
4台机器，2主2从，每个主实例挂一个从实例，2个节点对外提供读写操作，每个节点最高提供5w QPS，总共支持10w QPS。  
机器什么配置：32GB内存+8核+1T磁盘，限制分配给redis进程为10g，因为超过10g可能会有问题。4台机器对外提供读操作，2台机器提供写操作，占用总内存40g。  
每个主实例挂一个从实例，通过sentinal进行故障转移，实现高可用。  
往内存里写的什么数据？每条数据大小多少？专线数据，每条数据是10kb，100条就是1mb，10w条就是1gb。常驻内存的数据是50w条，占用内存5G，占用不到50%的总内存。  
目前高峰期每秒是1000左右的请求量。  
有专门的运维团队负责缓存集群的运维。

## 5、redis 线程模型
---
1）文件事件处理器

redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器，file event handler。这个文件事件处理器，是单线程的，redis才叫做单线程的模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。

如果被监听的socket准备好执行accept、read、write、close等操作的时候，跟操作对应的文件事件就会产生，这个时候文件事件处理器就会调用之前关联好的事件处理器来处理这个事件。

文件事件处理器是单线程模式运行的，但是通过IO多路复用机制监听多个socket，可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了redis内部的线程模型的简单性。

文件事件处理器的结构包含4个部分：多个socket，IO多路复用程序，文件事件分派器，事件处理器（命令请求处理器、命令回复处理器、连接应答处理器，等等）。

多个socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，但是会将socket放入一个队列中排队，每次从队列中取出一个socket给事件分派器，事件分派器把socket给对应的事件处理器。

然后一个socket的事件处理完之后，IO多路复用程序才会将队列中的下一个socket给事件分派器。文件事件分派器会根据每个socket当前产生的事件，来选择对应的事件处理器来处理。

2）文件事件

当socket变得可读时（比如客户端对redis执行write操作，或者close操作），或者有新的可以应答的sccket出现时（客户端对redis执行connect操作），socket就会产生一个AE_READABLE事件。

当socket变得可写的时候（客户端对redis执行read操作），socket会产生一个AE_WRITABLE事件。

IO多路复用程序可以同时监听AE_REABLE和AE_WRITABLE两种事件，要是一个socket同时产生了AE_READABLE和AE_WRITABLE两种事件，那么文件事件分派器优先处理AE_REABLE事件，然后才是AE_WRITABLE事件。

3）文件事件处理器

如果是客户端要连接redis，那么会为socket关联连接应答处理器
如果是客户端要写数据到redis，那么会为socket关联命令请求处理器
如果是客户端要从redis读数据，那么会为socket关联命令回复处理器

4）客户端与redis通信的一次流程

在redis启动初始化的时候，redis会将连接应答处理器跟AE_READABLE事件关联起来，接着如果一个客户端跟redis发起连接，此时会产生一个AE_READABLE事件，然后由连接应答处理器来处理跟客户端建立连接，创建客户端对应的socket，同时将这个socket的AE_READABLE事件跟命令请求处理器关联起来。

当客户端向redis发起请求的时候（不管是读请求还是写请求，都一样），首先就会在socket产生一个AE_READABLE事件，然后由对应的命令请求处理器来处理。这个命令请求处理器就会从socket中读取请求相关数据，然后进行执行和处理。

接着redis这边准备好了给客户端的响应数据之后，就会将socket的AE_WRITABLE事件跟命令回复处理器关联起来，当客户端这边准备好读取响应数据时，就会在socket上产生一个AE_WRITABLE事件，会由对应的命令回复处理器来处理，就是将准备好的响应数据写入socket，供客户端来读取。

命令回复处理器写完之后，就会删除这个socket的AE_WRITABLE事件和命令回复处理器的关联关系。

---

## Redis的集群模式
### 主从+哨兵模式
1. 哨兵的功能
    - 集群监控
    - 消息通知
    - 故障转移：选举Master node
    - 配置中心
2. 哨兵模式
    - 集群部署：高可用
### Redis cluster
1. 特点：  
1）数据自动分片  
2）高可用
1. 原因：单机在海量数据存在写瓶颈
2. 集群架构：多个master，每个master下有多个slaver；写master，读slaver；redis cluster 高可用，可以自动选举slaver为master
3. 集群架构比较  
redis cluster VS replica+sentinal  
1）如果数据量小，就用replica+sentinal 实现高并发/高可用  
2）海量数据，使用redis cluster 
4. 数据分布算法  
hash算法 -》 一致性hash算法 -》redis cluster，hash slot 算法  
1）hash算法：根据请求key对master节点取模，缺点是如果某个master宕机了，rehash之后，所有请求的缓存全部失效，会有大量缓存重建。  
2）一致性hash算法：hash成环，key 取模落在圆环的点上，顺时针找到最近的master节点，优点：保证只有宕机的master节点数据失效会重建，不会影响其他节点的缓存数据；缺点：缓存热点问题，可能热点缓存落在同一个master节点上，导致性能问题。  
虚拟节点：解决数据负载均衡问题，给每个master都做了均匀的虚拟节点，解决热点数据问题。  
3）hash slot 算法：16384 slot，key 计算crc16 取模，获取对应的key hash slot，每个master 持有部分hash slot，新增/删除机器，还是对hash slot取模，和机器无关；hash slot 的迁移由redis cluster 底层自己做的。
6. 节点间的内部通信机制  
1）基础通信节点  
（1）redis cluster节点间采取gossip协议进行通信  
跟集中式不同，不是将集群元数据（节点信息，故障，等等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的  
维护集群的元数据用得，集中式，一种叫做gossip  
集中式：好处在于，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到; 不好在于，所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力  
gossip：好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力; 缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后  
2）主备切换  
（1） 判断节点宕机：主观/客观宕机  
（2） 从节点过滤：检查每个slave node与master node断开连接的时间，如果超过了cluster-node-timeout * cluster-slave-validity-factor，那么就没有资格切换成master  
（3）从节点选举：哨兵：对所有从节点进行排序，slave priority，offset，run id  
每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举  
所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master  
从节点执行主备切换，从节点切换为主节点
7. redis cluster的优点
    - 无中心化
    - 故障转移
    - 客户端只需要连接集群任一节点即可
    - 高性能，客户端直连server
8. redis cluster 的缺点
    - 运维复杂，数据迁移需要人工干预
    - 只能使用0号数据库
    - 分布式和存储逻辑耦合

### 主从复制的核心原理
一个主库可以有多个从库，从库仅有一个主库，从库通过配置slaveof ,从主库同步数据，分为全量复制和部分复制。  
- 全量复制  
    1. 主节点通过bgsave命令fork一个主进程，生成二进制的快照文件rdb.dump文件
    2. 节点将rdb文件发送给从节点
    3. 从节点清空内存，重放rdb文件，阻塞操作，无法处理客户端请求
- 部分复制
    1. 复制偏移量：主从节点都维护一个自己的偏移量offset
    2. 复制积压缓冲区：主节点中维护了一个固定大小、先进先出的队列，用于存储主从复制期间的写数据，当主从节点之间的偏移量大于缓冲区大小，则只能进行全量复制
    3. 服务器运行ID（runID)：每个节点运行时都会分配一个唯一的id，从库会保存当前复制的主库runid，主从断开重连时，判断是否与旧runid一致，若一致尝试部分复制；若不一致，则进行全量复制；
- 主从复制流程
    1. 从服务器

## 开发
### 实际项目中用Redis要注意哪些规范
- 使用规范
1. 冷热数据区分：热数据存储在redis中，冷数据可存储在DB中
2. 命名规范，业务数据分离：不相关业务不放在一个Redis中，避免业务互相影响；也降低故障时影响范围；
3. 消息大小限制：Redis 是单线程服务，尽量保持在1KB以下，最大不超过50KB，基于带宽和磁盘IO持久化考虑。
4. 连接数限制：连接的频繁销毁和创建，大量浪费系统资源，正确设置连接数
5. 缓存key设置失效时间：缓存的key必须设置失效时间
6. 缓存不能有中间态：缓存应该仅作缓存用，去掉后业务逻辑不应发生改变，万不可切入到业务里
7. 扩展首选客户端hash：客户端hash进行集群拆分，若增加集群机器，在状态同步和持久化方面的性能很差  
- 操作规范：
1. 严禁使用 Keys
2. 严禁使用 Flush
3. 严禁作为消息队列使用：容量、网络、效率、功能方面的多种问题
4. 禁用 select 函数：cluster仅支持0
5. 禁用事务：缓存已经很快了
6. 禁用 lua 脚本扩展：会引入性能和一些难以维护的问题
7. Key 规范：业务、key 用途、变量等，各个维度使用 : 进行分隔