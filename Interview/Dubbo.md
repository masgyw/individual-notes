# Dubbo
（1）dubbo工作原理：服务注册，注册中心，消费者，代理通信，负载均衡  
（2）网络通信、序列化：dubbo协议，长连接，NIO，hessian序列化协议  
（3）负载均衡策略，集群容错策略，动态代理策略：dubbo跑起来的时候一些功能是如何运转的，怎么做负载均衡？怎么做集群容错？怎么生成动态代理？  
（4）dubbo SPI机制：你了解不了解dubbo的SPI机制？如何基于SPI机制对dubbo进行扩展？  

## 1 dubbo 的工作原理  
服务注册
#### 4.5.1 dubbo 支持哪些网络通信协议，优缺点  
1）dubbo协议
dubbo://  
单一长连接，NIO异步通信，基于hessian作为序列化协议  
优点：长连接，适用于高并发场景，数据量比较小100KB以内，消费者远大于生产者数量  
缺点：数据大，性能下降的很快  
2）rmi协议  
java二进制序列化，短链接，消费者和生产者差不多的情况，适用于文件传输  
3）hessian协议  
hessian 协议，短链接，  
4）http协议  
json序列化，短链接  
5）webservice  
SOAP 序列化  

#### 4.5.2 dubbo 支持哪些序列化，优缺点  
|序列化|优点|缺点|
|---|---|---|
|hession|||
|java|||
|json|||
|SOAP|||

#### 4.5.3 dubbo 负载均衡策略和集群容错策略都有哪些？动态代理策略呢？
负载均衡  
多个Provider集群，如何负载均衡  
1）默认random loadbalance，随机分配，可以设置权重  
2）roundrobin loadbalance，轮询，但是机器性能不同，可能导致某些机器负载较高，可以调整权重，性能差的权重小一点  
3）leastactive loadbalance，自动感知，性能差的请求少  
4）consistanthash loadbalance，一致性hash算法，相同参数的请求分发到一个provider上  
容错策略  
1）failover cluster模式  
失败自动切换，自动重试其他机器，默认就是这个，常见于读操作  
2）failfast cluster模式  
一次调用失败就立即失败，常见于写操作  
3）failsafe cluster模式  
出现异常时忽略掉，常用于不重要的接口调用，比如记录日志  
4）failback cluster模式  
失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种  
5）forking cluster  
并行调用多个provider，只要一个成功就立即返回  
6）broadcacst cluster  
逐个调用所有的provider  
动态代理策略  
默认使用javassist动态字节码生成，创建代理类  
但是可以通过spi扩展机制配置自己的动态代理策略  

#### 4.5.4 dubbo如何实现高扩展机制？什么是dubbo 的 SPI
1）SPI：service provider interface，比如有某个接口，有多个实现类，运行时对于使用哪个实现类？在配置文件中配置。
JDK 的SPI：通过jar包的方式给某个接口提供实现，然后你就在jar包的META/services/目录下放一个和接口同名的文件，里面指定接口的实现是jar中的某个类。  
其他人调用接口时，会调用你这个jar包的文件指定的那个类。
2）Dubbo 的spi 机制是如何实现的？  
dubbo提供所有组件全部接口化，组件间调用都是通过接口调用，必须依赖接口。  
以协议举例，可以自己实现Protocol 接口，在META-INF/services/目录下pei配置自己实现的Protocol实现，key=value形式，在使用是指定协议为key即可，若没有指定，则使用默认的。

#### 4.5.5 dubbo 如何做服务治理？服务降级、超时重试？
服务治理，大致有以下几个方面需要考虑：调用链路追踪、接口调用情况统计、服务鉴权、服务调用异常告警  
服务降级：Provider 提供配置mock 参数，接口+Mock 自动降级  
超时重试：Consumer 配置retries、timeout  

#### 4.5.6 分布式服务的接口幂等性如何保证？
幂等性接口是指重复请求时接口的准确性，例如不能重复扣款、重复入库。  
前提：请求要带有唯一标识，区分请求的重复性，有两种方式：
1）DB存储，在db 中存储一条操作流水，唯一标识约束，如果插入失败，则事务回滚，接口返回；  
2）redis 存储，set {key}=状态，接口操作时获取key 状态，如果已经操作了，就直接返回

#### 4.5.7 分布式服务接口的顺序性如何保证  
接口的顺序问题是指客户端发送请求1，2，3，分别被3个服务A 同时处理，顺序就不一致了，可能是3，2，1，导致数据操作异常。  
解决办法：
1）加一层中间接入服务，请求1、2、3 通过接入服务，hash 分发到一个服务A 中  
2）服务A 若是多线程，也可能导致顺序问题；可以在内存中使用队列，将同类请求添加到相同队列中  
以上办法可以适用绝大部分场景  
如果强制接口的顺序性，只能用分布式锁了，请求需要带有明确的顺序参数seq=1、2、3，服务需要获取分布式锁，然后去判断自己的顺序，前面的请求是否已经执行，
如果没有，则释放分布式锁，等待重新获取锁，最终保证接口的顺序性。这种方法性能非常差，频繁获取释放锁，可以引入MQ异步处理，快速响应客户端，不过吞吐量不高。  

#### 4.5.8 如何自己设计一个RPC 框架
远程调用框架，类似dubbo 
1. 动态代理：消费者和提供者，RPC框架的一切逻辑都是在代理对象里实现的，JDK提供了API生成动态代理
2. 服务注册：需要一个注册中心，例如Zookeeper，可以从注册中心获取所有服务的列表
3. 负载均衡：从服务列表中，根据负载均衡策略，选择一个服务供动态代理对象调用
3. 服务协议：选择一种协议，封装数据，例如http/xml；解析请求；
4. 服务通信：网络通信框架，序列化，把请求发送过去，例如Netty；接收请求，反序列化；
