[返回索引](./index.md)
# JVM 篇
JVM包含两个子系统和两个组件  
两个子系统为Class loader(类装载)、Execution engine(执行引擎)；  
两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)

## 一、基础
### java程序运行机制
1. .java 文件由编译器编译成 .class 二进制文件
2. 类加载器将 .class 加载到JVM 方法区中，在堆中生成Class 对象，保存类的信息
3. 使用类时，通过Class创建对象
### Java会存在内存泄漏吗？
内存泄漏：对象不使用，但是还在内存中

## 二、类加载机制
### 类加载过程
加载-》验证-》准备-》解析-》初始化-》实例化-》卸载  
1. 加载：通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象
2. 验证：验证class 的合法性
3. 准备：内存分配，为static 分配内存，设置初始值，final 变量在编译期分配
4. 解析：常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等
5. 初始化：只有类使用时才会初始化，静态代码块或静态变量的赋值，先初始化父类，再当前类
    - 触发条件：new 对象；访问类静态方法、静态变量；Class.forName反射时；访问某个子类初始化的时候；
6. 卸载：Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸载
### 类加载机制

## 三、执行引擎
###  JVM 运行时数据区
不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下5个部分：  
1. 虚拟机栈：栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
2. 本地方法栈：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的
3. 堆：内存中最大一片区域，所有线程共享的，几乎所有的对象实例都在这里分配内存；根据对象的不同，GC回收
4. 程序计数器：保存当前线程所执行的字节码位置，只为java方法服务，native 方法为空；字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成
5. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据，1.7 永久代、1.8 元空间
7. JMM（Java memory model），JVM规定了java内存模型，线程只能操作自己的工作副本，不能直接操作主内存；读主内存到工作副本，写工作副本到主内存
### 堆栈区别
1. 目的：栈是运行时单位，代表逻辑；堆是存储单位，代表数据
2. 物理地址：堆不连续，所以有碎片；栈连续
3. 存放内容：栈帧；对象
4. 程序可见：堆共享；栈私有；

## 四、垃圾回收 GC

### 内存模型
1. G1 之前
- yunger space
- old space
- perm space
- metaspace （1.8+）
2. G1 之后
堆内存会被切分成为很多个固定大小区域（Region），-XX:G1HeapRegionSize参数指定大小1M~32M

### 垃圾回收算法
1. G1算法  
- JDK1.9 默认回收算法，增量式清理
- 特点
    - 引入分区的思路，弱化了分代的概念，取消年轻代、老年代，而是使用若干个region 逻辑分区，用作年轻代和老年代，大对象
- 清理流程
    1. 初始标记：STW，标记处GCRoots可达的对象
    2. 并发标记：GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长
    3. 最终标记，STW
    4. 筛选回收：对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region
- GC模式
    1. youngGC：当所有eden region使用达到最大阀值并且无法申请足够内存时，会触发一次YoungGC，每次younggc会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区
    2. mixedGC：当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region
2. CMS 算法
- 清理流程

### 垃圾回收机制


### 垃圾回收器
1. 发展阶段
- Serial 串行：Serial + serial old
- Parallel 并行：ParNew + parallel old
- CMS 并发：parallel scanvage + CMS
- G1 并发：全代收集器
2. CMS 和 G1 区别

|项|CMS|G1|
|---|---|---|
|作用范围|老年代|整个区域|
|整理碎片|STW时整理内存空间|清理时即整理|
|内存模型|分代|分区|
|应用场景|普通场景|内存较大，碎片较多，可控的GC停顿，防止应用雪崩的场景|

### 对象内存分配规则
- CMS
    1. Eden 区创建
    2. Eden 区空间不足，复制存活对象到 Survivor 区；Survivor 区复制互换，清理，对象年龄+1
    3. Survivor 去年龄达到15，移动到Old 区
    4. 动态判断对象年龄：Survivor 区中相同年龄的所有对象大小的总和大于Survivor 区的一半，年龄大于等于该年龄的对象直接进入老年代
    5. 空间分配担保：每次Minor GC时，会计算Survivor 中进入老年代的平均大小，如果该值大于老年代剩余空间，直接full gc
- G1
    1. 每个Region被标记了E、S、O和H，这些区域在逻辑上被映射为Eden，Survivor和老年代
    2. 复制到其他区域


### 对象创建过程
1. JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用，然后加载这个类
2. 为对象分配内存，一种是“指针碰撞”、一种是“空闲列表“，最常用的办法“本地线程缓冲分配 TLAB“
3. 给除对象头外的对象内存空间初始化为0
4. 对对象头进行必要设置
### 简述Java的对象结构
Java对象由三个部分组成:对象头、实例数据、对齐填充  
对象头由两部分组成,第一部分存储对象自身的运行时数据:哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID(一般占32/64 bit)  
第二部分是指针类型,指向对象的类元数据类型(即对象代表哪个类)。  
如果是数组对象,则对象头中还有一部分用来记录数组长度。
实例数据用来存储对象真正的有效信息(包括父类继承下来的和自己定义的)  
对齐填充:JVM要求对象起始地址必须是8字节的整数倍(8字节对齐)

## 五、性能调优
### 什么时候会发生full GC？
1. 老年代内存不足
2. 方法区内存不足：CMS GC
3. CMS 发生promotion failed 和 concurrent mode failure
    - promotion failed:新生代放不下的对象，老年代也放不下，发生full GC
    - concurrent mode failure:GC过程中，大对象进入老年代，此时放不下，full GC
4. 统计得到的minor GC晋升到老年代的平均大小大于老年代剩余空间：例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先
检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC
5. System.gc : 可以通过-XX:+ DisableExplicitGC 禁止
### 调优工具
1. jdk自带监控工具：jconsole和jvisualvm
2. 第三方：MAT、GChisto
### JVM 性能调优
- 设定堆内存大小 -Xmx，-Xms
- 设定栈大小：-Xss
- 设定新生代大小: -XX:NewSize;-XX:newRatio;-XX:survivorRatio;
- 设定垃圾回收器: -XX:+UsexxxGC；-XX:UseParNewGC;-XX:UseConcMarkSweepGC
- 设置元数据空间：-XX:MetaSpaceSize，-XX:MaxMetaSpaceSize
### 内存溢出有哪些原因？
- 栈：递归调用，堆栈深度不够
- 堆：
    - 循环创建对象过多：优化代码逻辑
    - 列表中保留了不用对象的引用，导致内存泄漏：Mat 分析对象的引用链
    - 启动时设置的堆内存过小：启动时监控内存大小
    - 内存一次性加载数据量太大：条件查询，查询必须带条件
### JDK8 的perm space，是无限的吗？怎么限制大小？为什么要替换方法区为元空间？
JDK8 用元空间 meta space 来代替永久代，常量字符串存放在堆内存中  
元空间没有大小限制，根据实际内存动态调整  
-XX:MetaSpaceSize:分配给类元数据空间初始大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值  
-XX:MaxMetaSpaceSize:分配给类元数据空间的最大值，超过此值就会触发Full GC
元空间使用native memory，不会触发GC，根据机器实际内存动态调整
### JVM 线程dump 导出和分析
1. jps -l ：查看进程PID
2. top：查看当前进程使用资源情况
3. jstack -l <pid> > **.log：把进程pid的线程信息输出到指定log文件
4. top -H -p <pid>：找出某进程中要分析的线程ID，把线程ID转为16进制，在线程dump中查找线程相关信息，查看线程状态


## 六、执行模式

## 七、编译器优化